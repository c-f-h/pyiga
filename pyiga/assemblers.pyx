# cython: profile=False
# cython: linetrace=False
# cython: binding=False

#######################
# Autogenerated code. #
# Do not modify.      #
#######################

cimport cython
from libc.math cimport fabs, sqrt, exp, log, sin, cos, tan

import numpy as np
cimport numpy as np

from pyiga.quadrature import make_tensor_quadrature, make_boundary_quadrature

from pyiga.assemble_tools_cy cimport (
    BaseAssembler1D, BaseAssembler2D, BaseAssembler3D,
    BaseVectorAssembler1D, BaseVectorAssembler2D, BaseVectorAssembler3D,
    IntInterval, make_intv, intersect_intervals,
)
from pyiga.assemble_tools import compute_values_derivs
from pyiga.utils import LazyCachingArray, grid_eval, grid_eval_transformed

cdef class MassAssembler2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        self.fields = np.empty(N + (1,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        MassAssembler2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # W
                fields[0] = (GaussWeight * fabs(((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                r += (((VDu0[1*i0+0] * VDu1[1*i1+0]) * (VDv0[1*i0+0] * VDv1[1*i1+0])) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        cdef (double*) values_v[2]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        MassAssembler2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                values_v[0], values_v[1],
                result
        )

cdef class StiffnessAssembler2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - B: ofs=0 sz=3
        self.fields = np.empty(N + (3,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        StiffnessAssembler2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp2
        cdef double W
        cdef double _tmp1
        cdef double JacInv[4]
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # _tmp2
                _tmp2 = ((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))
                # W
                W = (GaussWeight * fabs(_tmp2))
                # _tmp1
                _tmp1 = (1.0 / _tmp2)
                # JacInv
                JacInv[0] = (_tmp1 * temp_fields[3])
                JacInv[1] = (_tmp1 * -temp_fields[1])
                JacInv[2] = (_tmp1 * -temp_fields[2])
                JacInv[3] = (_tmp1 * temp_fields[0])
                # B
                fields[0] = (W * ((JacInv[0] * JacInv[0]) + (JacInv[1] * JacInv[1])))
                fields[1] = (W * ((JacInv[0] * JacInv[2]) + (JacInv[1] * JacInv[3])))
                fields[2] = (W * ((JacInv[2] * JacInv[2]) + (JacInv[3] * JacInv[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_10
        cdef double _du_01
        cdef double _dv_10
        cdef double _dv_01
        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                # _du_10
                _du_10 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                # _du_01
                _du_01 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                # _dv_10
                _dv_10 = (VDv0[2*i0+0] * VDv1[2*i1+1])
                # _dv_01
                _dv_01 = (VDv0[2*i0+1] * VDv1[2*i1+0])
                r += ((((fields[0] * _du_10) + (fields[1] * _du_01)) * _dv_10) + (((fields[1] * _du_10) + (fields[2] * _du_01)) * _dv_01))
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        cdef (double*) values_v[2]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        StiffnessAssembler2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                values_v[0], values_v[1],
                result
        )

cdef class HeatAssembler_ST2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=4
        self.fields = np.empty(N + (5,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        HeatAssembler_ST2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # _tmp2
                _tmp2 = ((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))
                # _tmp1
                _tmp1 = (1.0 / _tmp2)
                # W
                fields[0] = (GaussWeight * fabs(_tmp2))
                # JacInv
                fields[1] = (_tmp1 * temp_fields[3])
                fields[2] = (_tmp1 * -temp_fields[1])
                fields[3] = (_tmp1 * -temp_fields[2])
                fields[4] = (_tmp1 * temp_fields[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_10
        cdef double _du_01
        cdef double _dv_10
        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                # _du_10
                _du_10 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                # _du_01
                _du_01 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                # _dv_10
                _dv_10 = (VDv0[2*i0+0] * VDv1[2*i1+1])
                r += ((((fields[1] * _du_10) * (fields[1] * _dv_10)) + (_du_01 * (VDv0[2*i0+0] * VDv1[2*i1+0]))) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        cdef (double*) values_v[2]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        HeatAssembler_ST2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                values_v[0], values_v[1],
                result
        )

cdef class WaveAssembler_ST2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=2)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=2)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=2)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=2)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=4
        self.fields = np.empty(N + (5,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        WaveAssembler_ST2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # _tmp2
                _tmp2 = ((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))
                # _tmp1
                _tmp1 = (1.0 / _tmp2)
                # W
                fields[0] = (GaussWeight * fabs(_tmp2))
                # JacInv
                fields[1] = (_tmp1 * temp_fields[3])
                fields[2] = (_tmp1 * -temp_fields[1])
                fields[3] = (_tmp1 * -temp_fields[2])
                fields[4] = (_tmp1 * temp_fields[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_02
        cdef double _du_10
        cdef double _dv_01
        cdef double _dv_11
        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                # _du_02
                _du_02 = (VDu0[3*i0+2] * VDu1[3*i1+0])
                # _du_10
                _du_10 = (VDu0[3*i0+0] * VDu1[3*i1+1])
                # _dv_01
                _dv_01 = (VDv0[3*i0+1] * VDv1[3*i1+0])
                # _dv_11
                _dv_11 = (VDv0[3*i0+1] * VDv1[3*i1+1])
                r += (((_du_02 * _dv_01) + ((fields[1] * _du_10) * (fields[1] * _dv_11))) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        cdef (double*) values_v[2]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        WaveAssembler_ST2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                values_v[0], values_v[1],
                result
        )

cdef class DivDivAssembler2D(BaseVectorAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        self.numcomp[:] = (2, 2,)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=4
        self.fields = np.empty(N + (5,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        DivDivAssembler2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # _tmp2
                _tmp2 = ((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))
                # _tmp1
                _tmp1 = (1.0 / _tmp2)
                # W
                fields[0] = (GaussWeight * fabs(_tmp2))
                # JacInv
                fields[1] = (_tmp1 * temp_fields[3])
                fields[2] = (_tmp1 * -temp_fields[1])
                fields[3] = (_tmp1 * -temp_fields[2])
                fields[4] = (_tmp1 * temp_fields[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) noexcept nogil:
        cdef double* r = [ 0.0, 0.0, 0.0, 0.0 ]

        cdef double _du_10
        cdef double _du_01
        cdef double _dv_10
        cdef double _dv_01
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp6
        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                # _du_10
                _du_10 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                # _du_01
                _du_01 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                # _dv_10
                _dv_10 = (VDv0[2*i0+0] * VDv1[2*i1+1])
                # _dv_01
                _dv_01 = (VDv0[2*i0+1] * VDv1[2*i1+0])
                # _tmp3
                _tmp3 = ((fields[1] * _du_10) + (fields[3] * _du_01))
                # _tmp4
                _tmp4 = ((fields[1] * _dv_10) + (fields[3] * _dv_01))
                # _tmp5
                _tmp5 = ((fields[2] * _du_10) + (fields[4] * _du_01))
                # _tmp6
                _tmp6 = ((fields[2] * _dv_10) + (fields[4] * _dv_01))
                r[0] += ((_tmp3 * _tmp4) * fields[0])
                r[1] += ((_tmp5 * _tmp4) * fields[0])
                r[2] += ((_tmp3 * _tmp6) * fields[0])
                r[3] += ((_tmp5 * _tmp6) * fields[0])
        result[0] = r[0]
        result[1] = r[1]
        result[2] = r[2]
        result[3] = r[3]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        cdef (double*) values_v[2]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        DivDivAssembler2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                values_v[0], values_v[1],
                result
        )

cdef class L2FunctionalAssembler2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
            'f': (),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo, f):
        self.arity = 1
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - f_a: ofs=0 sz=1
        #  - W: ofs=1 sz=1
        self.fields = np.empty(N + (2,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        self.fields.base[:, :, 0:1] = np.ascontiguousarray(grid_eval(f, self.gaussgrid)).reshape(N + (-1,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        L2FunctionalAssembler2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # W
                fields[1] = (GaussWeight * fabs(((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                r += ((fields[0] * (VDu0[1*i0+0] * VDu1[1*i1+0])) * fields[1])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        intv = make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1])
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1])
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        L2FunctionalAssembler2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                result
        )

cdef class L2FunctionalAssemblerPhys2D(BaseAssembler2D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (2,),
            'f': (),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo, f):
        self.arity = 1
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 2, "Geometry has wrong source dimension"
        assert geo.dim == 2, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]

        assert len(kvs0) == 2, "Assembler requires 2 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        assert len(kvs1) == 2, "Assembler requires 2 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - f_a: ofs=0 sz=1
        #  - W: ofs=1 sz=1
        self.fields = np.empty(N + (2,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=4
        cdef double[:, :, ::1] temp_fields = np.empty(N + (4,))
        self.fields.base[:, :, 0:1] = np.ascontiguousarray(grid_eval_transformed(f, self.gaussgrid, self._geo)).reshape(N + (-1,))
        temp_fields.base[:, :, 0:4] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        L2FunctionalAssemblerPhys2D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1,
            # Gauss weights
            double* _gw0, double* _gw1,
            # input
            double[:, :, ::1] _temp_fields,
            # output
            double[:, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]
                temp_fields = &_temp_fields[i0, i1, 0]

                # GaussWeight
                GaussWeight = (_gw0[i0] * _gw1[i1])
                # W
                fields[1] = (GaussWeight * fabs(((temp_fields[0] * temp_fields[3]) - (temp_fields[1] * temp_fields[2]))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1,
            double* _gw0, double* _gw1,
            double[:, :, :] _fields,
            double* VDu0, double* VDu1,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                fields = &_fields[i0, i1, 0]

                r += ((fields[0] * (VDu0[1*i0+0] * VDu1[1*i1+0])) * fields[1])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[2] i, size_t[2] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_u[2]
        intv = make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1])
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1])
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]

        L2FunctionalAssemblerPhys2D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1]],
                values_u[0], values_u[1],
                result
        )
cdef class MassAssembler3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=0)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        self.fields = np.empty(N + (1,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        MassAssembler3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # W
                    fields[0] = (GaussWeight * fabs((((temp_fields[0] * ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))) - (temp_fields[1] * ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6])))) + (temp_fields[2] * ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    r += (((VDu0[1*i0+0] * VDu1[1*i1+0] * VDu2[1*i2+0]) * (VDv0[1*i0+0] * VDv1[1*i1+0] * VDv2[1*i2+0])) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        cdef (double*) values_v[3]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp2[j[2],0], self.S0_meshsupp2[j[2],1]),
                make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ j[2], g_sta[2], 0 ]
        values_v[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        MassAssembler3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                values_v[0], values_v[1], values_v[2],
                result
        )

cdef class StiffnessAssembler3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=1)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - B: ofs=0 sz=6
        self.fields = np.empty(N + (6,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        StiffnessAssembler3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double W
        cdef double _tmp1
        cdef double JacInv[9]
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # _tmp3
                    _tmp3 = ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))
                    # _tmp4
                    _tmp4 = ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6]))
                    # _tmp5
                    _tmp5 = ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))
                    # _tmp2
                    _tmp2 = (((temp_fields[0] * _tmp3) - (temp_fields[1] * _tmp4)) + (temp_fields[2] * _tmp5))
                    # W
                    W = (GaussWeight * fabs(_tmp2))
                    # _tmp1
                    _tmp1 = (1.0 / _tmp2)
                    # JacInv
                    JacInv[0] = (_tmp1 * _tmp3)
                    JacInv[1] = (_tmp1 * -((temp_fields[1] * temp_fields[8]) - (temp_fields[2] * temp_fields[7])))
                    JacInv[2] = (_tmp1 * ((temp_fields[1] * temp_fields[5]) - (temp_fields[2] * temp_fields[4])))
                    JacInv[3] = (_tmp1 * -_tmp4)
                    JacInv[4] = (_tmp1 * ((temp_fields[0] * temp_fields[8]) - (temp_fields[2] * temp_fields[6])))
                    JacInv[5] = (_tmp1 * -((temp_fields[0] * temp_fields[5]) - (temp_fields[2] * temp_fields[3])))
                    JacInv[6] = (_tmp1 * _tmp5)
                    JacInv[7] = (_tmp1 * -((temp_fields[0] * temp_fields[7]) - (temp_fields[1] * temp_fields[6])))
                    JacInv[8] = (_tmp1 * ((temp_fields[0] * temp_fields[4]) - (temp_fields[1] * temp_fields[3])))
                    # B
                    fields[0] = (W * (((JacInv[0] * JacInv[0]) + (JacInv[1] * JacInv[1])) + (JacInv[2] * JacInv[2])))
                    fields[1] = (W * (((JacInv[0] * JacInv[3]) + (JacInv[1] * JacInv[4])) + (JacInv[2] * JacInv[5])))
                    fields[2] = (W * (((JacInv[0] * JacInv[6]) + (JacInv[1] * JacInv[7])) + (JacInv[2] * JacInv[8])))
                    fields[3] = (W * (((JacInv[3] * JacInv[3]) + (JacInv[4] * JacInv[4])) + (JacInv[5] * JacInv[5])))
                    fields[4] = (W * (((JacInv[3] * JacInv[6]) + (JacInv[4] * JacInv[7])) + (JacInv[5] * JacInv[8])))
                    fields[5] = (W * (((JacInv[6] * JacInv[6]) + (JacInv[7] * JacInv[7])) + (JacInv[8] * JacInv[8])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_100
        cdef double _du_010
        cdef double _du_001
        cdef double _dv_100
        cdef double _dv_010
        cdef double _dv_001
        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    # _du_100
                    _du_100 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    # _du_010
                    _du_010 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    # _du_001
                    _du_001 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    # _dv_100
                    _dv_100 = (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])
                    # _dv_010
                    _dv_010 = (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0])
                    # _dv_001
                    _dv_001 = (VDv0[2*i0+1] * VDv1[2*i1+0] * VDv2[2*i2+0])
                    r += ((((((fields[0] * _du_100) + (fields[1] * _du_010)) + (fields[2] * _du_001)) * _dv_100) + ((((fields[1] * _du_100) + (fields[3] * _du_010)) + (fields[4] * _du_001)) * _dv_010)) + ((((fields[2] * _du_100) + (fields[4] * _du_010)) + (fields[5] * _du_001)) * _dv_001))
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        cdef (double*) values_v[3]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp2[j[2],0], self.S0_meshsupp2[j[2],1]),
                make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ j[2], g_sta[2], 0 ]
        values_v[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        StiffnessAssembler3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                values_v[0], values_v[1], values_v[2],
                result
        )

cdef class HeatAssembler_ST3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=1)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=9
        self.fields = np.empty(N + (10,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        HeatAssembler_ST3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # _tmp3
                    _tmp3 = ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))
                    # _tmp4
                    _tmp4 = ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6]))
                    # _tmp5
                    _tmp5 = ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))
                    # _tmp2
                    _tmp2 = (((temp_fields[0] * _tmp3) - (temp_fields[1] * _tmp4)) + (temp_fields[2] * _tmp5))
                    # _tmp1
                    _tmp1 = (1.0 / _tmp2)
                    # W
                    fields[0] = (GaussWeight * fabs(_tmp2))
                    # JacInv
                    fields[1] = (_tmp1 * _tmp3)
                    fields[2] = (_tmp1 * -((temp_fields[1] * temp_fields[8]) - (temp_fields[2] * temp_fields[7])))
                    fields[3] = (_tmp1 * ((temp_fields[1] * temp_fields[5]) - (temp_fields[2] * temp_fields[4])))
                    fields[4] = (_tmp1 * -_tmp4)
                    fields[5] = (_tmp1 * ((temp_fields[0] * temp_fields[8]) - (temp_fields[2] * temp_fields[6])))
                    fields[6] = (_tmp1 * -((temp_fields[0] * temp_fields[5]) - (temp_fields[2] * temp_fields[3])))
                    fields[7] = (_tmp1 * _tmp5)
                    fields[8] = (_tmp1 * -((temp_fields[0] * temp_fields[7]) - (temp_fields[1] * temp_fields[6])))
                    fields[9] = (_tmp1 * ((temp_fields[0] * temp_fields[4]) - (temp_fields[1] * temp_fields[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_100
        cdef double _du_010
        cdef double _du_001
        cdef double _dv_100
        cdef double _dv_010
        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    # _du_100
                    _du_100 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    # _du_010
                    _du_010 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    # _du_001
                    _du_001 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    # _dv_100
                    _dv_100 = (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])
                    # _dv_010
                    _dv_010 = (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0])
                    r += ((((((fields[1] * _du_100) + (fields[4] * _du_010)) * ((fields[1] * _dv_100) + (fields[4] * _dv_010))) + (((fields[2] * _du_100) + (fields[5] * _du_010)) * ((fields[2] * _dv_100) + (fields[5] * _dv_010)))) + (_du_001 * (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+0]))) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        cdef (double*) values_v[3]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp2[j[2],0], self.S0_meshsupp2[j[2],1]),
                make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ j[2], g_sta[2], 0 ]
        values_v[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        HeatAssembler_ST3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                values_v[0], values_v[1], values_v[2],
                result
        )

cdef class WaveAssembler_ST3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=2)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=2)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=2)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=2)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=2)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=2)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=9
        self.fields = np.empty(N + (10,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        WaveAssembler_ST3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # _tmp3
                    _tmp3 = ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))
                    # _tmp4
                    _tmp4 = ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6]))
                    # _tmp5
                    _tmp5 = ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))
                    # _tmp2
                    _tmp2 = (((temp_fields[0] * _tmp3) - (temp_fields[1] * _tmp4)) + (temp_fields[2] * _tmp5))
                    # _tmp1
                    _tmp1 = (1.0 / _tmp2)
                    # W
                    fields[0] = (GaussWeight * fabs(_tmp2))
                    # JacInv
                    fields[1] = (_tmp1 * _tmp3)
                    fields[2] = (_tmp1 * -((temp_fields[1] * temp_fields[8]) - (temp_fields[2] * temp_fields[7])))
                    fields[3] = (_tmp1 * ((temp_fields[1] * temp_fields[5]) - (temp_fields[2] * temp_fields[4])))
                    fields[4] = (_tmp1 * -_tmp4)
                    fields[5] = (_tmp1 * ((temp_fields[0] * temp_fields[8]) - (temp_fields[2] * temp_fields[6])))
                    fields[6] = (_tmp1 * -((temp_fields[0] * temp_fields[5]) - (temp_fields[2] * temp_fields[3])))
                    fields[7] = (_tmp1 * _tmp5)
                    fields[8] = (_tmp1 * -((temp_fields[0] * temp_fields[7]) - (temp_fields[1] * temp_fields[6])))
                    fields[9] = (_tmp1 * ((temp_fields[0] * temp_fields[4]) - (temp_fields[1] * temp_fields[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double _du_002
        cdef double _du_100
        cdef double _du_010
        cdef double _dv_001
        cdef double _dv_101
        cdef double _dv_011
        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    # _du_002
                    _du_002 = (VDu0[3*i0+2] * VDu1[3*i1+0] * VDu2[3*i2+0])
                    # _du_100
                    _du_100 = (VDu0[3*i0+0] * VDu1[3*i1+0] * VDu2[3*i2+1])
                    # _du_010
                    _du_010 = (VDu0[3*i0+0] * VDu1[3*i1+1] * VDu2[3*i2+0])
                    # _dv_001
                    _dv_001 = (VDv0[3*i0+1] * VDv1[3*i1+0] * VDv2[3*i2+0])
                    # _dv_101
                    _dv_101 = (VDv0[3*i0+1] * VDv1[3*i1+0] * VDv2[3*i2+1])
                    # _dv_011
                    _dv_011 = (VDv0[3*i0+1] * VDv1[3*i1+1] * VDv2[3*i2+0])
                    r += (((_du_002 * _dv_001) + ((((fields[1] * _du_100) + (fields[4] * _du_010)) * ((fields[1] * _dv_101) + (fields[4] * _dv_011))) + (((fields[2] * _du_100) + (fields[5] * _du_010)) * ((fields[2] * _dv_101) + (fields[5] * _dv_011))))) * fields[0])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        cdef (double*) values_v[3]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp2[j[2],0], self.S0_meshsupp2[j[2],1]),
                make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ j[2], g_sta[2], 0 ]
        values_v[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        WaveAssembler_ST3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                values_v[0], values_v[1], values_v[2],
                result
        )

cdef class DivDivAssembler3D(BaseVectorAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo):
        self.arity = 2
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        self.numcomp[:] = (3, 3,)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=1)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=1)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=1)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=1)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=1)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=1)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - W: ofs=0 sz=1
        #  - JacInv: ofs=1 sz=9
        self.fields = np.empty(N + (10,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        DivDivAssembler3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double _tmp9
        cdef double _tmp10
        cdef double _tmp11
        cdef double _tmp2
        cdef double _tmp1
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # _tmp9
                    _tmp9 = ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))
                    # _tmp10
                    _tmp10 = ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6]))
                    # _tmp11
                    _tmp11 = ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))
                    # _tmp2
                    _tmp2 = (((temp_fields[0] * _tmp9) - (temp_fields[1] * _tmp10)) + (temp_fields[2] * _tmp11))
                    # _tmp1
                    _tmp1 = (1.0 / _tmp2)
                    # W
                    fields[0] = (GaussWeight * fabs(_tmp2))
                    # JacInv
                    fields[1] = (_tmp1 * _tmp9)
                    fields[2] = (_tmp1 * -((temp_fields[1] * temp_fields[8]) - (temp_fields[2] * temp_fields[7])))
                    fields[3] = (_tmp1 * ((temp_fields[1] * temp_fields[5]) - (temp_fields[2] * temp_fields[4])))
                    fields[4] = (_tmp1 * -_tmp10)
                    fields[5] = (_tmp1 * ((temp_fields[0] * temp_fields[8]) - (temp_fields[2] * temp_fields[6])))
                    fields[6] = (_tmp1 * -((temp_fields[0] * temp_fields[5]) - (temp_fields[2] * temp_fields[3])))
                    fields[7] = (_tmp1 * _tmp11)
                    fields[8] = (_tmp1 * -((temp_fields[0] * temp_fields[7]) - (temp_fields[1] * temp_fields[6])))
                    fields[9] = (_tmp1 * ((temp_fields[0] * temp_fields[4]) - (temp_fields[1] * temp_fields[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) noexcept nogil:
        cdef double* r = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]

        cdef double _du_100
        cdef double _du_010
        cdef double _du_001
        cdef double _dv_100
        cdef double _dv_010
        cdef double _dv_001
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp6
        cdef double _tmp7
        cdef double _tmp8
        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    # _du_100
                    _du_100 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    # _du_010
                    _du_010 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    # _du_001
                    _du_001 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    # _dv_100
                    _dv_100 = (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])
                    # _dv_010
                    _dv_010 = (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0])
                    # _dv_001
                    _dv_001 = (VDv0[2*i0+1] * VDv1[2*i1+0] * VDv2[2*i2+0])
                    # _tmp3
                    _tmp3 = (((fields[1] * _du_100) + (fields[4] * _du_010)) + (fields[7] * _du_001))
                    # _tmp4
                    _tmp4 = (((fields[1] * _dv_100) + (fields[4] * _dv_010)) + (fields[7] * _dv_001))
                    # _tmp5
                    _tmp5 = (((fields[2] * _du_100) + (fields[5] * _du_010)) + (fields[8] * _du_001))
                    # _tmp6
                    _tmp6 = (((fields[3] * _du_100) + (fields[6] * _du_010)) + (fields[9] * _du_001))
                    # _tmp7
                    _tmp7 = (((fields[2] * _dv_100) + (fields[5] * _dv_010)) + (fields[8] * _dv_001))
                    # _tmp8
                    _tmp8 = (((fields[3] * _dv_100) + (fields[6] * _dv_010)) + (fields[9] * _dv_001))
                    r[0] += ((_tmp3 * _tmp4) * fields[0])
                    r[1] += ((_tmp5 * _tmp4) * fields[0])
                    r[2] += ((_tmp6 * _tmp4) * fields[0])
                    r[3] += ((_tmp3 * _tmp7) * fields[0])
                    r[4] += ((_tmp5 * _tmp7) * fields[0])
                    r[5] += ((_tmp6 * _tmp7) * fields[0])
                    r[6] += ((_tmp3 * _tmp8) * fields[0])
                    r[7] += ((_tmp5 * _tmp8) * fields[0])
                    r[8] += ((_tmp6 * _tmp8) * fields[0])
        result[0] = r[0]
        result[1] = r[1]
        result[2] = r[2]
        result[3] = r[3]
        result[4] = r[4]
        result[5] = r[5]
        result[6] = r[6]
        result[7] = r[7]
        result[8] = r[8]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        cdef (double*) values_v[3]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp0[j[0],0], self.S0_meshsupp0[j[0],1]),
                make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ j[0], g_sta[0], 0 ]
        values_v[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp1[j[1],0], self.S0_meshsupp1[j[1],1]),
                make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ j[1], g_sta[1], 0 ]
        values_v[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = intersect_intervals(
                make_intv(self.S0_meshsupp2[j[2],0], self.S0_meshsupp2[j[2],1]),
                make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1]),
        )
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ j[2], g_sta[2], 0 ]
        values_v[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        DivDivAssembler3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                values_v[0], values_v[1], values_v[2],
                result
        )

cdef class L2FunctionalAssembler3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
            'f': (),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo, f):
        self.arity = 1
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=0)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - f_a: ofs=0 sz=1
        #  - W: ofs=1 sz=1
        self.fields = np.empty(N + (2,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        self.fields.base[:, :, :, 0:1] = np.ascontiguousarray(grid_eval(f, self.gaussgrid)).reshape(N + (-1,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        L2FunctionalAssembler3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # W
                    fields[1] = (GaussWeight * fabs((((temp_fields[0] * ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))) - (temp_fields[1] * ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6])))) + (temp_fields[2] * ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    r += ((fields[0] * (VDu0[1*i0+0] * VDu1[1*i1+0] * VDu2[1*i2+0])) * fields[1])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        intv = make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1])
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1])
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1])
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        L2FunctionalAssembler3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                result
        )

cdef class L2FunctionalAssemblerPhys3D(BaseAssembler3D):
    @classmethod
    def inputs(cls):
        return {
            'geo': (3,),
            'f': (),
        }

    @classmethod
    def parameters(cls):
        return {
        }

    def __init__(self, kvs0, geo, f):
        self.arity = 1
        self.nqp = max([kv.p for kv in kvs0]) + 1
        kvs1 = kvs0
        self.kvs = (kvs0, kvs1)
        assert geo.sdim == 3, "Geometry has wrong source dimension"
        assert geo.dim == 3, "Geometry has wrong dimension"
        self._geo = geo

        # NB: we assume all kvs result in the same mesh
        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs0], self.nqp)
        self.gaussgrid = gaussgrid
        self.gaussweights0 = gaussweights[0]
        self.gaussweights1 = gaussweights[1]
        self.gaussweights2 = gaussweights[2]

        assert len(kvs0) == 3, "Assembler requires 3 knot vectors"
        self.S0_ndofs[:] = [kv.numdofs for kv in kvs0]
        self.S0_meshsupp0 = self.nqp * kvs0[0].mesh_support_idx_all()
        self.S0_C0 = compute_values_derivs(kvs0[0], gaussgrid[0], derivs=0)
        self.S0_meshsupp1 = self.nqp * kvs0[1].mesh_support_idx_all()
        self.S0_C1 = compute_values_derivs(kvs0[1], gaussgrid[1], derivs=0)
        self.S0_meshsupp2 = self.nqp * kvs0[2].mesh_support_idx_all()
        self.S0_C2 = compute_values_derivs(kvs0[2], gaussgrid[2], derivs=0)
        assert len(kvs1) == 3, "Assembler requires 3 knot vectors"
        self.S1_ndofs[:] = [kv.numdofs for kv in kvs1]
        self.S1_meshsupp0 = self.nqp * kvs1[0].mesh_support_idx_all()
        self.S1_C0 = compute_values_derivs(kvs1[0], gaussgrid[0], derivs=0)
        self.S1_meshsupp1 = self.nqp * kvs1[1].mesh_support_idx_all()
        self.S1_C1 = compute_values_derivs(kvs1[1], gaussgrid[1], derivs=0)
        self.S1_meshsupp2 = self.nqp * kvs1[2].mesh_support_idx_all()
        self.S1_C2 = compute_values_derivs(kvs1[2], gaussgrid[2], derivs=0)

        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        # Fields:
        #  - f_a: ofs=0 sz=1
        #  - W: ofs=1 sz=1
        self.fields = np.empty(N + (2,))
        # Temp fields:
        #  - geo_grad_a: ofs=0 sz=9
        cdef double[:, :, :, ::1] temp_fields = np.empty(N + (9,))
        self.fields.base[:, :, :, 0:1] = np.ascontiguousarray(grid_eval_transformed(f, self.gaussgrid, self._geo)).reshape(N + (-1,))
        temp_fields.base[:, :, :, 0:9] = np.ascontiguousarray(geo.grid_jacobian(self.gaussgrid)).reshape(N + (-1,))
        L2FunctionalAssemblerPhys3D.precompute_fields(
                gaussgrid[0].shape[0], gaussgrid[1].shape[0], gaussgrid[2].shape[0],
                &self.gaussweights0[0], &self.gaussweights1[0], &self.gaussweights2[0],
                temp_fields,
                self.fields,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # dimensions
            size_t n0, size_t n1, size_t n2,
            # Gauss weights
            double* _gw0, double* _gw1, double* _gw2,
            # input
            double[:, :, :, ::1] _temp_fields,
            # output
            double[:, :, :, ::1] _fields,
        ) noexcept nogil:
        cdef double GaussWeight
        cdef double* fields
        cdef double* temp_fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]
                    temp_fields = &_temp_fields[i0, i1, i2, 0]

                    # GaussWeight
                    GaussWeight = ((_gw0[i0] * _gw1[i1]) * _gw2[i2])
                    # W
                    fields[1] = (GaussWeight * fabs((((temp_fields[0] * ((temp_fields[4] * temp_fields[8]) - (temp_fields[5] * temp_fields[7]))) - (temp_fields[1] * ((temp_fields[3] * temp_fields[8]) - (temp_fields[5] * temp_fields[6])))) + (temp_fields[2] * ((temp_fields[3] * temp_fields[7]) - (temp_fields[4] * temp_fields[6]))))))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            size_t n0, size_t n1, size_t n2,
            double* _gw0, double* _gw1, double* _gw2,
            double[:, :, :, :] _fields,
            double* VDu0, double* VDu1, double* VDu2,
            double result[]
        ) noexcept nogil:
        cdef double r = 0.0

        cdef double* fields
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    fields = &_fields[i0, i1, i2, 0]

                    r += ((fields[0] * (VDu0[1*i0+0] * VDu1[1*i1+0] * VDu2[1*i2+0])) * fields[1])
        result[0] = r

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void entry_impl(self, size_t[3] i, size_t[3] j, double result[]) noexcept nogil:
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_u[3]
        intv = make_intv(self.S0_meshsupp0[i[0],0], self.S0_meshsupp0[i[0],1])
        g_sta[0] = intv.a    # start of Gauss nodes
        g_end[0] = intv.b    # end of Gauss nodes
        values_u[0] = &self.S0_C0[ i[0], g_sta[0], 0 ]
        intv = make_intv(self.S0_meshsupp1[i[1],0], self.S0_meshsupp1[i[1],1])
        g_sta[1] = intv.a    # start of Gauss nodes
        g_end[1] = intv.b    # end of Gauss nodes
        values_u[1] = &self.S0_C1[ i[1], g_sta[1], 0 ]
        intv = make_intv(self.S0_meshsupp2[i[2],0], self.S0_meshsupp2[i[2],1])
        g_sta[2] = intv.a    # start of Gauss nodes
        g_end[2] = intv.b    # end of Gauss nodes
        values_u[2] = &self.S0_C2[ i[2], g_sta[2], 0 ]

        L2FunctionalAssemblerPhys3D.combine(
                g_end[0]-g_sta[0], g_end[1]-g_sta[1], g_end[2]-g_sta[2],
                &self.gaussweights0[g_sta[0]], &self.gaussweights1[g_sta[1]], &self.gaussweights2[g_sta[2]],
                self.fields[g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2]],
                values_u[0], values_u[1], values_u[2],
                result
        )
