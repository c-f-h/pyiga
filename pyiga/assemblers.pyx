# cython: language_level=3
# cython: profile=False
# cython: linetrace=False
# cython: binding=False

#######################
# Autogenerated code. #
# Do not modify.      #
#######################

cimport cython
from libc.math cimport fabs

import numpy as np
cimport numpy as np

from pyiga.quadrature import make_tensor_quadrature

from pyiga.assemble_tools_cy cimport (
    BaseAssembler2D, BaseAssembler3D,
    BaseVectorAssembler2D, BaseVectorAssembler3D,
    IntInterval, make_intv, intersect_intervals,
)
from pyiga.assemble_tools_cy import compute_values_derivs

cdef class MassAssembler2D(BaseAssembler2D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, ::1] W

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 2, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=0)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=0)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None] * gaussweights[1][None,:]
        self.W = np.empty(N + ())
        MassAssembler2D.precompute_fields(
                geo_jac,
                gauss_weights,
                self.W,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, :, ::1] _Jac,
            double[:, ::1] _GaussWeight,
            # output
            double[:, ::1] _W,
        ) nogil:
        cdef size_t n0 = _Jac.shape[0]
        cdef size_t n1 = _Jac.shape[1]
        cdef double* Jac
        cdef double GaussWeight
        cdef double W
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                Jac = &_Jac[i0, i1, 0, 0]
                GaussWeight = _GaussWeight[i0, i1]

                W = (GaussWeight * fabs(((Jac[0] * Jac[3]) - (Jac[1] * Jac[2]))))
                _W[i0, i1] = W

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, ::1] _W,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef double W
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                W = _W[i0, i1]

                result += (((VDu0[1*i0+0] * VDu1[1*i1+0]) * (VDv0[1*i0+0] * VDv1[1*i1+0])) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]

        return MassAssembler2D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_j[0], values_j[1],
                values_i[0], values_i[1],
        )

cdef class StiffnessAssembler2D(BaseAssembler2D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, :, ::1] B

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 2, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None] * gaussweights[1][None,:]
        self.B = np.empty(N + (2, 2))
        StiffnessAssembler2D.precompute_fields(
                geo_jac,
                gauss_weights,
                self.B,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, :, ::1] _Jac,
            double[:, ::1] _GaussWeight,
            # output
            double[:, :, :, ::1] _B,
        ) nogil:
        cdef size_t n0 = _Jac.shape[0]
        cdef size_t n1 = _Jac.shape[1]
        cdef double _tmp2
        cdef double _tmp1
        cdef double JacInv[4]
        cdef double W
        cdef double* Jac
        cdef double GaussWeight
        cdef double* B
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                Jac = &_Jac[i0, i1, 0, 0]
                GaussWeight = _GaussWeight[i0, i1]
                B = &_B[i0, i1, 0, 0]

                _tmp2 = ((Jac[0] * Jac[3]) - (Jac[1] * Jac[2]))
                _tmp1 = (1.0 / _tmp2)
                JacInv[0] = (_tmp1 * Jac[3])
                JacInv[1] = (_tmp1 * -Jac[1])
                JacInv[2] = (_tmp1 * -Jac[2])
                JacInv[3] = (_tmp1 * Jac[0])
                W = (GaussWeight * fabs(_tmp2))
                B[0] = (W * ((JacInv[0] * JacInv[0]) + (JacInv[1] * JacInv[1])))
                B[1] = (W * ((JacInv[0] * JacInv[2]) + (JacInv[1] * JacInv[3])))
                B[3] = (W * ((JacInv[2] * JacInv[2]) + (JacInv[3] * JacInv[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, :, :, ::1] _B,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _B.shape[0]
        cdef size_t n1 = _B.shape[1]
        cdef double _tmp3
        cdef double _tmp4
        cdef double* B
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                B = &_B[i0, i1, 0, 0]

                _tmp3 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                _tmp4 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                result += ((((B[0] * _tmp3) + (B[1] * _tmp4)) * (VDv0[2*i0+0] * VDv1[2*i1+1])) + (((B[1] * _tmp3) + (B[3] * _tmp4)) * (VDv0[2*i0+1] * VDv1[2*i1+0])))
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]

        return StiffnessAssembler2D.combine(
                self.B [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_j[0], values_j[1],
                values_i[0], values_i[1],
        )

cdef class HeatAssembler_ST2D(BaseAssembler2D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, ::1] W
    cdef double[:, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 2, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None] * gaussweights[1][None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (2, 2))
        HeatAssembler_ST2D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, ::1] _GaussWeight,
            double[:, :, :, ::1] _Jac,
            # output
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                GaussWeight = _GaussWeight[i0, i1]
                Jac = &_Jac[i0, i1, 0, 0]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _tmp2 = ((Jac[0] * Jac[3]) - (Jac[1] * Jac[2]))
                _tmp1 = (1.0 / _tmp2)
                W = (GaussWeight * fabs(_tmp2))
                _W[i0, i1] = W
                JacInv[0] = (_tmp1 * Jac[3])
                JacInv[1] = (_tmp1 * -Jac[1])
                JacInv[2] = (_tmp1 * -Jac[2])
                JacInv[3] = (_tmp1 * Jac[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef double _dv_10
        cdef double _du_10
        cdef double _du_01
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                W = _W[i0, i1]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _dv_10 = (VDv0[2*i0+0] * VDv1[2*i1+1])
                _du_10 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                _du_01 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                result += ((((JacInv[0] * _du_10) * (JacInv[0] * _dv_10)) + (_du_01 * (VDv0[2*i0+0] * VDv1[2*i1+0]))) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]

        return HeatAssembler_ST2D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_j[0], values_j[1],
                values_i[0], values_i[1],
        )

cdef class WaveAssembler_ST2D(BaseAssembler2D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, ::1] W
    cdef double[:, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 2, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=2)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=2)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None] * gaussweights[1][None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (2, 2))
        WaveAssembler_ST2D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, ::1] _GaussWeight,
            double[:, :, :, ::1] _Jac,
            # output
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                GaussWeight = _GaussWeight[i0, i1]
                Jac = &_Jac[i0, i1, 0, 0]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _tmp2 = ((Jac[0] * Jac[3]) - (Jac[1] * Jac[2]))
                _tmp1 = (1.0 / _tmp2)
                W = (GaussWeight * fabs(_tmp2))
                _W[i0, i1] = W
                JacInv[0] = (_tmp1 * Jac[3])
                JacInv[1] = (_tmp1 * -Jac[1])
                JacInv[2] = (_tmp1 * -Jac[2])
                JacInv[3] = (_tmp1 * Jac[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef double _dv_01
        cdef double _dv_11
        cdef double _du_02
        cdef double _du_10
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                W = _W[i0, i1]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _dv_01 = (VDv0[3*i0+1] * VDv1[3*i1+0])
                _dv_11 = (VDv0[3*i0+1] * VDv1[3*i1+1])
                _du_02 = (VDu0[3*i0+2] * VDu1[3*i1+0])
                _du_10 = (VDu0[3*i0+0] * VDu1[3*i1+1])
                result += (((_du_02 * _dv_01) + ((JacInv[0] * _du_10) * (JacInv[0] * _dv_11))) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]

        return WaveAssembler_ST2D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_j[0], values_j[1],
                values_i[0], values_i[1],
        )

cdef class DivDivAssembler2D(BaseVectorAssembler2D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, ::1] W
    cdef double[:, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs, (2, 2,))
        assert geo.dim == 2, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None] * gaussweights[1][None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (2, 2))
        DivDivAssembler2D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, ::1] _GaussWeight,
            double[:, :, :, ::1] _Jac,
            # output
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                GaussWeight = _GaussWeight[i0, i1]
                Jac = &_Jac[i0, i1, 0, 0]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _tmp2 = ((Jac[0] * Jac[3]) - (Jac[1] * Jac[2]))
                _tmp1 = (1.0 / _tmp2)
                W = (GaussWeight * fabs(_tmp2))
                _W[i0, i1] = W
                JacInv[0] = (_tmp1 * Jac[3])
                JacInv[1] = (_tmp1 * -Jac[1])
                JacInv[2] = (_tmp1 * -Jac[2])
                JacInv[3] = (_tmp1 * Jac[0])

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            double[:, ::1] _W,
            double[:, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1,
            double* VDv0, double* VDv1,
            double result[]
        ) nogil:

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef double _dv_10
        cdef double _dv_01
        cdef double _tmp4
        cdef double _tmp6
        cdef double _du_10
        cdef double _du_01
        cdef double _tmp3
        cdef double _tmp5
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1

        for i0 in range(n0):
            for i1 in range(n1):
                W = _W[i0, i1]
                JacInv = &_JacInv[i0, i1, 0, 0]

                _dv_10 = (VDv0[2*i0+0] * VDv1[2*i1+1])
                _dv_01 = (VDv0[2*i0+1] * VDv1[2*i1+0])
                _tmp4 = ((JacInv[0] * _dv_10) + (JacInv[2] * _dv_01))
                _tmp6 = ((JacInv[1] * _dv_10) + (JacInv[3] * _dv_01))
                _du_10 = (VDu0[2*i0+0] * VDu1[2*i1+1])
                _du_01 = (VDu0[2*i0+1] * VDu1[2*i1+0])
                _tmp3 = ((JacInv[0] * _du_10) + (JacInv[2] * _du_01))
                _tmp5 = ((JacInv[1] * _du_10) + (JacInv[3] * _du_01))
                result[0] += ((_tmp3 * _tmp4) * W)
                result[1] += ((_tmp5 * _tmp4) * W)
                result[2] += ((_tmp3 * _tmp6) * W)
                result[3] += ((_tmp5 * _tmp6) * W)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void assemble_impl(self, size_t[2] i, size_t[2] j, double result[]) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]

        DivDivAssembler2D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_j[0], values_j[1],
                values_i[0], values_i[1],
                result
        )
cdef class MassAssembler3D(BaseAssembler3D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, ::1] C2
    cdef double[:, :, ::1] W

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 3, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=0)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=0)
        self.C2 = compute_values_derivs(kvs[2], gaussgrid[2], derivs=0)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:]
        self.W = np.empty(N + ())
        MassAssembler3D.precompute_fields(
                geo_jac,
                gauss_weights,
                self.W,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, :, :, ::1] _Jac,
            double[:, :, ::1] _GaussWeight,
            # output
            double[:, :, ::1] _W,
        ) nogil:
        cdef size_t n0 = _Jac.shape[0]
        cdef size_t n1 = _Jac.shape[1]
        cdef size_t n2 = _Jac.shape[2]
        cdef double* Jac
        cdef double GaussWeight
        cdef double W
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    Jac = &_Jac[i0, i1, i2, 0, 0]
                    GaussWeight = _GaussWeight[i0, i1, i2]

                    W = (GaussWeight * fabs((((Jac[0] * ((Jac[4] * Jac[8]) - (Jac[5] * Jac[7]))) - (Jac[1] * ((Jac[3] * Jac[8]) - (Jac[5] * Jac[6])))) + (Jac[2] * ((Jac[3] * Jac[7]) - (Jac[4] * Jac[6]))))))
                    _W[i0, i1, i2] = W

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, :, ::1] _W,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef size_t n2 = _W.shape[2]
        cdef double W
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    W = _W[i0, i1, i2]

                    result += (((VDu0[1*i0+0] * VDu1[1*i1+0] * VDu2[1*i2+0]) * (VDv0[1*i0+0] * VDv1[1*i1+0] * VDv2[1*i2+0])) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp2[i[2],0], self.meshsupp2[i[2],1]),
                                      make_intv(self.meshsupp2[j[2],0], self.meshsupp2[j[2],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[2] = self.nqp * intv.a    # start of Gauss nodes
        g_end[2] = self.nqp * intv.b    # end of Gauss nodes
        values_i[2] = &self.C2[ i[2], g_sta[2], 0 ]
        values_j[2] = &self.C2[ j[2], g_sta[2], 0 ]

        return MassAssembler3D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_j[0], values_j[1], values_j[2],
                values_i[0], values_i[1], values_i[2],
        )

cdef class StiffnessAssembler3D(BaseAssembler3D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, ::1] C2
    cdef double[:, :, :, :, ::1] B

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 3, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)
        self.C2 = compute_values_derivs(kvs[2], gaussgrid[2], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:]
        self.B = np.empty(N + (3, 3))
        StiffnessAssembler3D.precompute_fields(
                geo_jac,
                gauss_weights,
                self.B,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, :, :, ::1] _Jac,
            double[:, :, ::1] _GaussWeight,
            # output
            double[:, :, :, :, ::1] _B,
        ) nogil:
        cdef size_t n0 = _Jac.shape[0]
        cdef size_t n1 = _Jac.shape[1]
        cdef size_t n2 = _Jac.shape[2]
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double _tmp1
        cdef double JacInv[9]
        cdef double W
        cdef double* Jac
        cdef double GaussWeight
        cdef double* B
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    Jac = &_Jac[i0, i1, i2, 0, 0]
                    GaussWeight = _GaussWeight[i0, i1, i2]
                    B = &_B[i0, i1, i2, 0, 0]

                    _tmp3 = ((Jac[4] * Jac[8]) - (Jac[5] * Jac[7]))
                    _tmp4 = ((Jac[3] * Jac[8]) - (Jac[5] * Jac[6]))
                    _tmp5 = ((Jac[3] * Jac[7]) - (Jac[4] * Jac[6]))
                    _tmp2 = (((Jac[0] * _tmp3) - (Jac[1] * _tmp4)) + (Jac[2] * _tmp5))
                    _tmp1 = (1.0 / _tmp2)
                    JacInv[0] = (_tmp1 * _tmp3)
                    JacInv[1] = (_tmp1 * -((Jac[1] * Jac[8]) - (Jac[2] * Jac[7])))
                    JacInv[2] = (_tmp1 * ((Jac[1] * Jac[5]) - (Jac[2] * Jac[4])))
                    JacInv[3] = (_tmp1 * -_tmp4)
                    JacInv[4] = (_tmp1 * ((Jac[0] * Jac[8]) - (Jac[2] * Jac[6])))
                    JacInv[5] = (_tmp1 * -((Jac[0] * Jac[5]) - (Jac[2] * Jac[3])))
                    JacInv[6] = (_tmp1 * _tmp5)
                    JacInv[7] = (_tmp1 * -((Jac[0] * Jac[7]) - (Jac[1] * Jac[6])))
                    JacInv[8] = (_tmp1 * ((Jac[0] * Jac[4]) - (Jac[1] * Jac[3])))
                    W = (GaussWeight * fabs(_tmp2))
                    B[0] = (W * (((JacInv[0] * JacInv[0]) + (JacInv[1] * JacInv[1])) + (JacInv[2] * JacInv[2])))
                    B[1] = (W * (((JacInv[0] * JacInv[3]) + (JacInv[1] * JacInv[4])) + (JacInv[2] * JacInv[5])))
                    B[2] = (W * (((JacInv[0] * JacInv[6]) + (JacInv[1] * JacInv[7])) + (JacInv[2] * JacInv[8])))
                    B[4] = (W * (((JacInv[3] * JacInv[3]) + (JacInv[4] * JacInv[4])) + (JacInv[5] * JacInv[5])))
                    B[5] = (W * (((JacInv[3] * JacInv[6]) + (JacInv[4] * JacInv[7])) + (JacInv[5] * JacInv[8])))
                    B[8] = (W * (((JacInv[6] * JacInv[6]) + (JacInv[7] * JacInv[7])) + (JacInv[8] * JacInv[8])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, :, :, :, ::1] _B,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _B.shape[0]
        cdef size_t n1 = _B.shape[1]
        cdef size_t n2 = _B.shape[2]
        cdef double _tmp6
        cdef double _tmp7
        cdef double _tmp8
        cdef double* B
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    B = &_B[i0, i1, i2, 0, 0]

                    _tmp6 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    _tmp7 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    _tmp8 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    result += ((((((B[0] * _tmp6) + (B[1] * _tmp7)) + (B[2] * _tmp8)) * (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])) + ((((B[1] * _tmp6) + (B[4] * _tmp7)) + (B[5] * _tmp8)) * (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0]))) + ((((B[2] * _tmp6) + (B[5] * _tmp7)) + (B[8] * _tmp8)) * (VDv0[2*i0+1] * VDv1[2*i1+0] * VDv2[2*i2+0])))
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp2[i[2],0], self.meshsupp2[i[2],1]),
                                      make_intv(self.meshsupp2[j[2],0], self.meshsupp2[j[2],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[2] = self.nqp * intv.a    # start of Gauss nodes
        g_end[2] = self.nqp * intv.b    # end of Gauss nodes
        values_i[2] = &self.C2[ i[2], g_sta[2], 0 ]
        values_j[2] = &self.C2[ j[2], g_sta[2], 0 ]

        return StiffnessAssembler3D.combine(
                self.B [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_j[0], values_j[1], values_j[2],
                values_i[0], values_i[1], values_i[2],
        )

cdef class HeatAssembler_ST3D(BaseAssembler3D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, ::1] C2
    cdef double[:, :, ::1] W
    cdef double[:, :, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 3, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)
        self.C2 = compute_values_derivs(kvs[2], gaussgrid[2], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (3, 3))
        HeatAssembler_ST3D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, ::1] _GaussWeight,
            double[:, :, :, :, ::1] _Jac,
            # output
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef size_t n2 = _GaussWeight.shape[2]
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    GaussWeight = _GaussWeight[i0, i1, i2]
                    Jac = &_Jac[i0, i1, i2, 0, 0]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _tmp3 = ((Jac[4] * Jac[8]) - (Jac[5] * Jac[7]))
                    _tmp4 = ((Jac[3] * Jac[8]) - (Jac[5] * Jac[6]))
                    _tmp5 = ((Jac[3] * Jac[7]) - (Jac[4] * Jac[6]))
                    _tmp2 = (((Jac[0] * _tmp3) - (Jac[1] * _tmp4)) + (Jac[2] * _tmp5))
                    _tmp1 = (1.0 / _tmp2)
                    W = (GaussWeight * fabs(_tmp2))
                    _W[i0, i1, i2] = W
                    JacInv[0] = (_tmp1 * _tmp3)
                    JacInv[1] = (_tmp1 * -((Jac[1] * Jac[8]) - (Jac[2] * Jac[7])))
                    JacInv[2] = (_tmp1 * ((Jac[1] * Jac[5]) - (Jac[2] * Jac[4])))
                    JacInv[3] = (_tmp1 * -_tmp4)
                    JacInv[4] = (_tmp1 * ((Jac[0] * Jac[8]) - (Jac[2] * Jac[6])))
                    JacInv[5] = (_tmp1 * -((Jac[0] * Jac[5]) - (Jac[2] * Jac[3])))
                    JacInv[6] = (_tmp1 * _tmp5)
                    JacInv[7] = (_tmp1 * -((Jac[0] * Jac[7]) - (Jac[1] * Jac[6])))
                    JacInv[8] = (_tmp1 * ((Jac[0] * Jac[4]) - (Jac[1] * Jac[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef size_t n2 = _W.shape[2]
        cdef double _dv_100
        cdef double _dv_010
        cdef double _du_100
        cdef double _du_010
        cdef double _du_001
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    W = _W[i0, i1, i2]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _dv_100 = (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])
                    _dv_010 = (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0])
                    _du_100 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    _du_010 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    _du_001 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    result += ((((((JacInv[0] * _du_100) + (JacInv[3] * _du_010)) * ((JacInv[0] * _dv_100) + (JacInv[3] * _dv_010))) + (((JacInv[1] * _du_100) + (JacInv[4] * _du_010)) * ((JacInv[1] * _dv_100) + (JacInv[4] * _dv_010)))) + (_du_001 * (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+0]))) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp2[i[2],0], self.meshsupp2[i[2],1]),
                                      make_intv(self.meshsupp2[j[2],0], self.meshsupp2[j[2],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[2] = self.nqp * intv.a    # start of Gauss nodes
        g_end[2] = self.nqp * intv.b    # end of Gauss nodes
        values_i[2] = &self.C2[ i[2], g_sta[2], 0 ]
        values_j[2] = &self.C2[ j[2], g_sta[2], 0 ]

        return HeatAssembler_ST3D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_j[0], values_j[1], values_j[2],
                values_i[0], values_i[1], values_i[2],
        )

cdef class WaveAssembler_ST3D(BaseAssembler3D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, ::1] C2
    cdef double[:, :, ::1] W
    cdef double[:, :, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs)
        assert geo.dim == 3, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=2)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=2)
        self.C2 = compute_values_derivs(kvs[2], gaussgrid[2], derivs=2)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (3, 3))
        WaveAssembler_ST3D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, ::1] _GaussWeight,
            double[:, :, :, :, ::1] _Jac,
            # output
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef size_t n2 = _GaussWeight.shape[2]
        cdef double _tmp3
        cdef double _tmp4
        cdef double _tmp5
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    GaussWeight = _GaussWeight[i0, i1, i2]
                    Jac = &_Jac[i0, i1, i2, 0, 0]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _tmp3 = ((Jac[4] * Jac[8]) - (Jac[5] * Jac[7]))
                    _tmp4 = ((Jac[3] * Jac[8]) - (Jac[5] * Jac[6]))
                    _tmp5 = ((Jac[3] * Jac[7]) - (Jac[4] * Jac[6]))
                    _tmp2 = (((Jac[0] * _tmp3) - (Jac[1] * _tmp4)) + (Jac[2] * _tmp5))
                    _tmp1 = (1.0 / _tmp2)
                    W = (GaussWeight * fabs(_tmp2))
                    _W[i0, i1, i2] = W
                    JacInv[0] = (_tmp1 * _tmp3)
                    JacInv[1] = (_tmp1 * -((Jac[1] * Jac[8]) - (Jac[2] * Jac[7])))
                    JacInv[2] = (_tmp1 * ((Jac[1] * Jac[5]) - (Jac[2] * Jac[4])))
                    JacInv[3] = (_tmp1 * -_tmp4)
                    JacInv[4] = (_tmp1 * ((Jac[0] * Jac[8]) - (Jac[2] * Jac[6])))
                    JacInv[5] = (_tmp1 * -((Jac[0] * Jac[5]) - (Jac[2] * Jac[3])))
                    JacInv[6] = (_tmp1 * _tmp5)
                    JacInv[7] = (_tmp1 * -((Jac[0] * Jac[7]) - (Jac[1] * Jac[6])))
                    JacInv[8] = (_tmp1 * ((Jac[0] * Jac[4]) - (Jac[1] * Jac[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef double combine(
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
        ) nogil:
        cdef double result = 0.0

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef size_t n2 = _W.shape[2]
        cdef double _dv_001
        cdef double _dv_101
        cdef double _dv_011
        cdef double _du_002
        cdef double _du_100
        cdef double _du_010
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    W = _W[i0, i1, i2]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _dv_001 = (VDv0[3*i0+1] * VDv1[3*i1+0] * VDv2[3*i2+0])
                    _dv_101 = (VDv0[3*i0+1] * VDv1[3*i1+0] * VDv2[3*i2+1])
                    _dv_011 = (VDv0[3*i0+1] * VDv1[3*i1+1] * VDv2[3*i2+0])
                    _du_002 = (VDu0[3*i0+2] * VDu1[3*i1+0] * VDu2[3*i2+0])
                    _du_100 = (VDu0[3*i0+0] * VDu1[3*i1+0] * VDu2[3*i2+1])
                    _du_010 = (VDu0[3*i0+0] * VDu1[3*i1+1] * VDu2[3*i2+0])
                    result += (((_du_002 * _dv_001) + ((((JacInv[0] * _du_100) + (JacInv[3] * _du_010)) * ((JacInv[0] * _dv_101) + (JacInv[3] * _dv_011))) + (((JacInv[1] * _du_100) + (JacInv[4] * _du_010)) * ((JacInv[1] * _dv_101) + (JacInv[4] * _dv_011))))) * W)
        return result

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp2[i[2],0], self.meshsupp2[i[2],1]),
                                      make_intv(self.meshsupp2[j[2],0], self.meshsupp2[j[2],1]))
        if intv.a >= intv.b: return 0.0  # no intersection of support
        g_sta[2] = self.nqp * intv.a    # start of Gauss nodes
        g_end[2] = self.nqp * intv.b    # end of Gauss nodes
        values_i[2] = &self.C2[ i[2], g_sta[2], 0 ]
        values_j[2] = &self.C2[ j[2], g_sta[2], 0 ]

        return WaveAssembler_ST3D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_j[0], values_j[1], values_j[2],
                values_i[0], values_i[1], values_i[2],
        )

cdef class DivDivAssembler3D(BaseVectorAssembler3D):
    # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, ::1] C0
    cdef double[:, :, ::1] C1
    cdef double[:, :, ::1] C2
    cdef double[:, :, ::1] W
    cdef double[:, :, :, :, ::1] JacInv

    def __init__(self, kvs, geo):
        self.base_init(kvs, (3, 3,))
        assert geo.dim == 3, "Geometry has wrong dimension"

        gaussgrid, gaussweights = make_tensor_quadrature([kv.mesh for kv in kvs], self.nqp)
        N = tuple(gg.shape[0] for gg in gaussgrid)  # grid dimensions

        self.C0 = compute_values_derivs(kvs[0], gaussgrid[0], derivs=1)
        self.C1 = compute_values_derivs(kvs[1], gaussgrid[1], derivs=1)
        self.C2 = compute_values_derivs(kvs[2], gaussgrid[2], derivs=1)

        geo_jac = geo.grid_jacobian(gaussgrid)
        gauss_weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:]
        self.W = np.empty(N + ())
        self.JacInv = np.empty(N + (3, 3))
        DivDivAssembler3D.precompute_fields(
                gauss_weights,
                geo_jac,
                self.W,
                self.JacInv,
        )

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void precompute_fields(
            # input
            double[:, :, ::1] _GaussWeight,
            double[:, :, :, :, ::1] _Jac,
            # output
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
        ) nogil:
        cdef size_t n0 = _GaussWeight.shape[0]
        cdef size_t n1 = _GaussWeight.shape[1]
        cdef size_t n2 = _GaussWeight.shape[2]
        cdef double _tmp9
        cdef double _tmp10
        cdef double _tmp11
        cdef double _tmp2
        cdef double _tmp1
        cdef double GaussWeight
        cdef double* Jac
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    GaussWeight = _GaussWeight[i0, i1, i2]
                    Jac = &_Jac[i0, i1, i2, 0, 0]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _tmp9 = ((Jac[4] * Jac[8]) - (Jac[5] * Jac[7]))
                    _tmp10 = ((Jac[3] * Jac[8]) - (Jac[5] * Jac[6]))
                    _tmp11 = ((Jac[3] * Jac[7]) - (Jac[4] * Jac[6]))
                    _tmp2 = (((Jac[0] * _tmp9) - (Jac[1] * _tmp10)) + (Jac[2] * _tmp11))
                    _tmp1 = (1.0 / _tmp2)
                    W = (GaussWeight * fabs(_tmp2))
                    _W[i0, i1, i2] = W
                    JacInv[0] = (_tmp1 * _tmp9)
                    JacInv[1] = (_tmp1 * -((Jac[1] * Jac[8]) - (Jac[2] * Jac[7])))
                    JacInv[2] = (_tmp1 * ((Jac[1] * Jac[5]) - (Jac[2] * Jac[4])))
                    JacInv[3] = (_tmp1 * -_tmp10)
                    JacInv[4] = (_tmp1 * ((Jac[0] * Jac[8]) - (Jac[2] * Jac[6])))
                    JacInv[5] = (_tmp1 * -((Jac[0] * Jac[5]) - (Jac[2] * Jac[3])))
                    JacInv[6] = (_tmp1 * _tmp11)
                    JacInv[7] = (_tmp1 * -((Jac[0] * Jac[7]) - (Jac[1] * Jac[6])))
                    JacInv[8] = (_tmp1 * ((Jac[0] * Jac[4]) - (Jac[1] * Jac[3])))

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    @staticmethod
    cdef void combine(
            double[:, :, ::1] _W,
            double[:, :, :, :, ::1] _JacInv,
            double* VDu0, double* VDu1, double* VDu2,
            double* VDv0, double* VDv1, double* VDv2,
            double result[]
        ) nogil:

        cdef size_t n0 = _W.shape[0]
        cdef size_t n1 = _W.shape[1]
        cdef size_t n2 = _W.shape[2]
        cdef double _dv_100
        cdef double _dv_010
        cdef double _dv_001
        cdef double _tmp4
        cdef double _tmp7
        cdef double _tmp8
        cdef double _du_100
        cdef double _du_010
        cdef double _du_001
        cdef double _tmp3
        cdef double _tmp5
        cdef double _tmp6
        cdef double W
        cdef double* JacInv
        cdef size_t i0
        cdef size_t i1
        cdef size_t i2

        for i0 in range(n0):
            for i1 in range(n1):
                for i2 in range(n2):
                    W = _W[i0, i1, i2]
                    JacInv = &_JacInv[i0, i1, i2, 0, 0]

                    _dv_100 = (VDv0[2*i0+0] * VDv1[2*i1+0] * VDv2[2*i2+1])
                    _dv_010 = (VDv0[2*i0+0] * VDv1[2*i1+1] * VDv2[2*i2+0])
                    _dv_001 = (VDv0[2*i0+1] * VDv1[2*i1+0] * VDv2[2*i2+0])
                    _tmp4 = (((JacInv[0] * _dv_100) + (JacInv[3] * _dv_010)) + (JacInv[6] * _dv_001))
                    _tmp7 = (((JacInv[1] * _dv_100) + (JacInv[4] * _dv_010)) + (JacInv[7] * _dv_001))
                    _tmp8 = (((JacInv[2] * _dv_100) + (JacInv[5] * _dv_010)) + (JacInv[8] * _dv_001))
                    _du_100 = (VDu0[2*i0+0] * VDu1[2*i1+0] * VDu2[2*i2+1])
                    _du_010 = (VDu0[2*i0+0] * VDu1[2*i1+1] * VDu2[2*i2+0])
                    _du_001 = (VDu0[2*i0+1] * VDu1[2*i1+0] * VDu2[2*i2+0])
                    _tmp3 = (((JacInv[0] * _du_100) + (JacInv[3] * _du_010)) + (JacInv[6] * _du_001))
                    _tmp5 = (((JacInv[1] * _du_100) + (JacInv[4] * _du_010)) + (JacInv[7] * _du_001))
                    _tmp6 = (((JacInv[2] * _du_100) + (JacInv[5] * _du_010)) + (JacInv[8] * _du_001))
                    result[0] += ((_tmp3 * _tmp4) * W)
                    result[1] += ((_tmp5 * _tmp4) * W)
                    result[2] += ((_tmp6 * _tmp4) * W)
                    result[3] += ((_tmp3 * _tmp7) * W)
                    result[4] += ((_tmp5 * _tmp7) * W)
                    result[5] += ((_tmp6 * _tmp7) * W)
                    result[6] += ((_tmp3 * _tmp8) * W)
                    result[7] += ((_tmp5 * _tmp8) * W)
                    result[8] += ((_tmp6 * _tmp8) * W)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef void assemble_impl(self, size_t[3] i, size_t[3] j, double result[]) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]
        intv = intersect_intervals(make_intv(self.meshsupp0[i[0],0], self.meshsupp0[i[0],1]),
                                      make_intv(self.meshsupp0[j[0],0], self.meshsupp0[j[0],1]))
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[0] = self.nqp * intv.a    # start of Gauss nodes
        g_end[0] = self.nqp * intv.b    # end of Gauss nodes
        values_i[0] = &self.C0[ i[0], g_sta[0], 0 ]
        values_j[0] = &self.C0[ j[0], g_sta[0], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp1[i[1],0], self.meshsupp1[i[1],1]),
                                      make_intv(self.meshsupp1[j[1],0], self.meshsupp1[j[1],1]))
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[1] = self.nqp * intv.a    # start of Gauss nodes
        g_end[1] = self.nqp * intv.b    # end of Gauss nodes
        values_i[1] = &self.C1[ i[1], g_sta[1], 0 ]
        values_j[1] = &self.C1[ j[1], g_sta[1], 0 ]
        intv = intersect_intervals(make_intv(self.meshsupp2[i[2],0], self.meshsupp2[i[2],1]),
                                      make_intv(self.meshsupp2[j[2],0], self.meshsupp2[j[2],1]))
        if intv.a >= intv.b: return   # no intersection of support
        g_sta[2] = self.nqp * intv.a    # start of Gauss nodes
        g_end[2] = self.nqp * intv.b    # end of Gauss nodes
        values_i[2] = &self.C2[ i[2], g_sta[2], 0 ]
        values_j[2] = &self.C2[ j[2], g_sta[2], 0 ]

        DivDivAssembler3D.combine(
                self.W [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                self.JacInv [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_j[0], values_j[1], values_j[2],
                values_i[0], values_i[1], values_i[2],
                result
        )
